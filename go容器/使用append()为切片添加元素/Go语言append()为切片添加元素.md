Go语言的内建函数 append() 可以为切片动态添加元素，代码如下所示：
+ 案例
    * 1.go

不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。

切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充，例如 1、2、4、8、16……，代码如下：    
+ 案例
    * 2.go

代码说明如下：
- 第 1 行，声明一个整型切片。
- 第 4 行，循环向 numbers 切片中添加 10 个数。
- 第 5 行，打印输出切片的长度、容量和指针变化，使用函数 len() 查看切片拥有的元素个数，使用函数 cap() 查看切片的容量情况。

通过查看代码输出，可以发现一个有意思的规律：切片长度 len 并不等于切片的容量 cap。

往一个切片中不断添加元素的过程，类似于公司搬家，公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工，随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变，因此公司只能选择搬家，每次搬家就需要将所有的人员转移到新的办公点。
员工和工位就是切片中的元素。
办公地就是分配好的内存。
搬家就是重新分配内存。
无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。
由于搬家后地址发生变化，因此内存“地址”也会有修改。

除了在切片的尾部追加，我们还可以在切片的开头添加元素：    
+ 案例
    * 3.go

在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。

因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：
+ 案例
    * 4.go

每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。
